/*
 * generated by Xtext 2.10.0
 */
grammar InternalPhases;

options {
	superClass=AbstractInternalAntlrParser;
}

@lexer::header {
package org.xtext.de.htwg.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package org.xtext.de.htwg.parser.antlr.internal;

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.xtext.de.htwg.services.PhasesGrammarAccess;

}

@parser::members {

 	private PhasesGrammarAccess grammarAccess;

    public InternalPhasesParser(TokenStream input, PhasesGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }

    @Override
    protected String getFirstRuleName() {
    	return "Game";
   	}

   	@Override
   	protected PhasesGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}

}

@rulecatch {
    catch (RecognitionException re) {
        recover(input,re);
        appendSkippedTokens();
    }
}

// Entry rule entryRuleGame
entryRuleGame returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getGameRule()); }
	iv_ruleGame=ruleGame
	{ $current=$iv_ruleGame.current; }
	EOF;

// Rule Game
ruleGame returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			{
				newCompositeNode(grammarAccess.getGameAccess().getPhasesPhaseParserRuleCall_0());
			}
			lv_phases_0_0=rulePhase
			{
				if ($current==null) {
					$current = createModelElementForParent(grammarAccess.getGameRule());
				}
				add(
					$current,
					"phases",
					lv_phases_0_0,
					"org.xtext.de.htwg.Phases.Phase");
				afterParserOrEnumRuleCall();
			}
		)
	)*
;

// Entry rule entryRulePhase
entryRulePhase returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPhaseRule()); }
	iv_rulePhase=rulePhase
	{ $current=$iv_rulePhase.current; }
	EOF;

// Rule Phase
rulePhase returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		otherlv_0='PHASE'
		{
			newLeafNode(otherlv_0, grammarAccess.getPhaseAccess().getPHASEKeyword_0());
		}
		(
			(
				lv_phaseNumber_1_0=RULE_INT
				{
					newLeafNode(lv_phaseNumber_1_0, grammarAccess.getPhaseAccess().getPhaseNumberINTTerminalRuleCall_1_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getPhaseRule());
					}
					setWithLastConsumed(
						$current,
						"phaseNumber",
						lv_phaseNumber_1_0,
						"org.eclipse.xtext.common.Terminals.INT");
				}
			)
		)
		(
			(
				{
					newCompositeNode(grammarAccess.getPhaseAccess().getPhaseTypePhaseTypeParserRuleCall_2_0());
				}
				lv_phaseType_2_0=rulePhaseType
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPhaseRule());
					}
					set(
						$current,
						"phaseType",
						lv_phaseType_2_0,
						"org.xtext.de.htwg.Phases.PhaseType");
					afterParserOrEnumRuleCall();
				}
			)
		)
		(
			(
				lv_phaseDescription_3_0=RULE_STRING
				{
					newLeafNode(lv_phaseDescription_3_0, grammarAccess.getPhaseAccess().getPhaseDescriptionSTRINGTerminalRuleCall_3_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getPhaseRule());
					}
					setWithLastConsumed(
						$current,
						"phaseDescription",
						lv_phaseDescription_3_0,
						"org.eclipse.xtext.common.Terminals.STRING");
				}
			)
		)
	)
;

// Entry rule entryRulePhaseType
entryRulePhaseType returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getPhaseTypeRule()); }
	iv_rulePhaseType=rulePhaseType
	{ $current=$iv_rulePhaseType.current; }
	EOF;

// Rule PhaseType
rulePhaseType returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				{
					newCompositeNode(grammarAccess.getPhaseTypeAccess().getStreetTypeSTREET_TYPEParserRuleCall_0_0());
				}
				lv_streetType_0_0=ruleSTREET_TYPE
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPhaseTypeRule());
					}
					set(
						$current,
						"streetType",
						lv_streetType_0_0,
						"org.xtext.de.htwg.Phases.STREET_TYPE");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getPhaseTypeAccess().getNumbersTypeNUMBERS_TYPEParserRuleCall_1_0());
				}
				lv_numbersType_1_0=ruleNUMBERS_TYPE
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPhaseTypeRule());
					}
					set(
						$current,
						"numbersType",
						lv_numbersType_1_0,
						"org.xtext.de.htwg.Phases.NUMBERS_TYPE");
					afterParserOrEnumRuleCall();
				}
			)
		)
		    |
		(
			(
				{
					newCompositeNode(grammarAccess.getPhaseTypeAccess().getColorTypeCOLORS_TYPEParserRuleCall_2_0());
				}
				lv_colorType_2_0=ruleCOLORS_TYPE
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getPhaseTypeRule());
					}
					set(
						$current,
						"colorType",
						lv_colorType_2_0,
						"org.xtext.de.htwg.Phases.COLORS_TYPE");
					afterParserOrEnumRuleCall();
				}
			)
		)
	)
;

// Entry rule entryRuleNUMBERS_TYPE
entryRuleNUMBERS_TYPE returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getNUMBERS_TYPERule()); }
	iv_ruleNUMBERS_TYPE=ruleNUMBERS_TYPE
	{ $current=$iv_ruleNUMBERS_TYPE.current; }
	EOF;

// Rule NUMBERS_TYPE
ruleNUMBERS_TYPE returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_0_0='NUMBERS'
				{
					newLeafNode(lv_name_0_0, grammarAccess.getNUMBERS_TYPEAccess().getNameNUMBERSKeyword_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getNUMBERS_TYPERule());
					}
					setWithLastConsumed($current, "name", lv_name_0_0, "NUMBERS");
				}
			)
		)
		otherlv_1=':'
		{
			newLeafNode(otherlv_1, grammarAccess.getNUMBERS_TYPEAccess().getColonKeyword_1());
		}
		(
			(
				{
					newCompositeNode(grammarAccess.getNUMBERS_TYPEAccess().getNumbersTypeNUMBERSParserRuleCall_2_0());
				}
				lv_numbersType_2_0=ruleNUMBERS
				{
					if ($current==null) {
						$current = createModelElementForParent(grammarAccess.getNUMBERS_TYPERule());
					}
					add(
						$current,
						"numbersType",
						lv_numbersType_2_0,
						"org.xtext.de.htwg.Phases.NUMBERS");
					afterParserOrEnumRuleCall();
				}
			)
		)*
	)
;

// Entry rule entryRuleNUMBERS
entryRuleNUMBERS returns [String current=null]:
	{ newCompositeNode(grammarAccess.getNUMBERSRule()); }
	iv_ruleNUMBERS=ruleNUMBERS
	{ $current=$iv_ruleNUMBERS.current.getText(); }
	EOF;

// Rule NUMBERS
ruleNUMBERS returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		kw='DOUBLE'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getNUMBERSAccess().getDOUBLEKeyword_0());
		}
		    |
		kw='TRIPLE'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getNUMBERSAccess().getTRIPLEKeyword_1());
		}
		    |
		kw='QUADRUPLE'
		{
			$current.merge(kw);
			newLeafNode(kw, grammarAccess.getNUMBERSAccess().getQUADRUPLEKeyword_2());
		}
	)
;

// Entry rule entryRuleCOLORS_TYPE
entryRuleCOLORS_TYPE returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getCOLORS_TYPERule()); }
	iv_ruleCOLORS_TYPE=ruleCOLORS_TYPE
	{ $current=$iv_ruleCOLORS_TYPE.current; }
	EOF;

// Rule COLORS_TYPE
ruleCOLORS_TYPE returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_0_0='COLORS'
				{
					newLeafNode(lv_name_0_0, grammarAccess.getCOLORS_TYPEAccess().getNameCOLORSKeyword_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getCOLORS_TYPERule());
					}
					setWithLastConsumed($current, "name", lv_name_0_0, "COLORS");
				}
			)
		)
		otherlv_1=':'
		{
			newLeafNode(otherlv_1, grammarAccess.getCOLORS_TYPEAccess().getColonKeyword_1());
		}
		(
			(
				lv_numberColors_2_0=RULE_INT
				{
					newLeafNode(lv_numberColors_2_0, grammarAccess.getCOLORS_TYPEAccess().getNumberColorsINTTerminalRuleCall_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getCOLORS_TYPERule());
					}
					setWithLastConsumed(
						$current,
						"numberColors",
						lv_numberColors_2_0,
						"org.eclipse.xtext.common.Terminals.INT");
				}
			)
		)
	)
;

// Entry rule entryRuleSTREET_TYPE
entryRuleSTREET_TYPE returns [EObject current=null]:
	{ newCompositeNode(grammarAccess.getSTREET_TYPERule()); }
	iv_ruleSTREET_TYPE=ruleSTREET_TYPE
	{ $current=$iv_ruleSTREET_TYPE.current; }
	EOF;

// Rule STREET_TYPE
ruleSTREET_TYPE returns [EObject current=null]
@init {
	enterRule();
}
@after {
	leaveRule();
}:
	(
		(
			(
				lv_name_0_0='STREET'
				{
					newLeafNode(lv_name_0_0, grammarAccess.getSTREET_TYPEAccess().getNameSTREETKeyword_0_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getSTREET_TYPERule());
					}
					setWithLastConsumed($current, "name", lv_name_0_0, "STREET");
				}
			)
		)
		otherlv_1=':'
		{
			newLeafNode(otherlv_1, grammarAccess.getSTREET_TYPEAccess().getColonKeyword_1());
		}
		(
			(
				lv_streetLenght_2_0=RULE_INT
				{
					newLeafNode(lv_streetLenght_2_0, grammarAccess.getSTREET_TYPEAccess().getStreetLenghtINTTerminalRuleCall_2_0());
				}
				{
					if ($current==null) {
						$current = createModelElement(grammarAccess.getSTREET_TYPERule());
					}
					setWithLastConsumed(
						$current,
						"streetLenght",
						lv_streetLenght_2_0,
						"org.eclipse.xtext.common.Terminals.INT");
				}
			)
		)
	)
;

RULE_ID : '^'? ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

RULE_INT : ('0'..'9')+;

RULE_STRING : ('"' ('\\' .|~(('\\'|'"')))* '"'|'\'' ('\\' .|~(('\\'|'\'')))* '\'');

RULE_ML_COMMENT : '/*' ( options {greedy=false;} : . )*'*/';

RULE_SL_COMMENT : '//' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_ANY_OTHER : .;
